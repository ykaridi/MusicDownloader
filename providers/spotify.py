from typing import Tuple, Optional, Union, Dict, Iterator, Iterable

import requests
from spotipy import Spotify

from core import SongInformationProvider, SongInformation, AlbumInformationProvider, PNGSongImage, JPEGSongImage


FEATURES = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness', 'instrumentalness',
            'liveness', 'valence', 'tempo']


class SpotifyProvider(SongInformationProvider, AlbumInformationProvider):
    """
    Song and Album information providers from Spotify
    """

    def __init__(self, api: Spotify):
        self.api = api

    @staticmethod
    def _fetch_image(url: str) -> Optional[Union[PNGSongImage, JPEGSongImage]]:
        """Fetch an image from Spotify, assumes payload is either PNG or JPEG"""
        response = requests.get(url)
        if response.headers['Content-Type'] == 'image/png':
            return PNGSongImage(response.content)
        elif response.headers['Content-Type'] == 'image/jpeg':
            return JPEGSongImage(response.content)

        return None

    def _parse_track(self, obj: Dict, add_features: bool = True) -> SongInformation:
        """Parse a track object generated by the Spotify API"""

        def _fetch_features(track_id: str) -> Dict[str, float]:
            feature_dict = self.api.audio_features([track_id])[0]
            return {k: v for k, v in feature_dict.items() if k in FEATURES}

        track_id: str = obj['id']

        name: str = obj.get('name', None)
        album: str = obj.get('album', {}).get('name', None)

        _release_date: str = obj.get('album', {}).get('release_date', None)
        year: int = int(_release_date.split("-")[0]) if _release_date is not None else None

        _track_number: str = obj.get('track_number', None)
        track_number: int = int(_track_number) if _track_number is not None else None

        total_tracks: int = obj.get('album', {}).get('total_tracks', 0)

        _artists: Tuple[str, ...] = tuple(art['name'] for art in obj.get('artists', {}))
        artists: Tuple[str, ...] = _artists if len(_artists) > 0 else None

        links: Dict[str, str] = obj.get('external_urls', None)

        image_url: str = obj.get('album', {}).get('images', [{}])[0].get('url', None)
        image: Optional[Union[PNGSongImage, JPEGSongImage]] = self._fetch_image(image_url) \
            if image_url is not None else None

        _additional_information = _fetch_features(track_id) if add_features else {}
        additional_information = "\n".join(f"{k} {v}" for k, v in _additional_information.items())

        return SongInformation(name, album, (track_number, total_tracks), artists, image, year, links=links,
                               additional_information=additional_information)

    def _all_items(self, result: dict) -> Iterator[dict]:
        while result is not None:
            yield from result['items']
            result = self.api.next(result['next']) if result['next'] else None

    def _search(self, query_type: str, limit: int = 10, **query: Optional[str]) -> Iterator[dict]:
        """Perform a Spotify query"""
        initial_result = self.api.search(" ".join(f"{k}:{v}" for k, v in query.items() if v is not None),
                                         type=query_type, limit=limit)[query_type + "s"]
        return self._all_items(initial_result)

    def _search_track(self, track: Optional[str] = None, album: Optional[str] = None, artist: Optional[str] = None)\
            -> Iterator[SongInformation]:
        """Search for a track given track name, (optional) album name and (optional) artist"""
        for result in self._search(query_type="track", track=track, album=album, artist=artist):
            yield self._parse_track(result)

    def _search_album_songs(self, album: Optional[str] = None, artist: Optional[str] = None) ->\
            Iterator[Tuple[str, Tuple[SongInformation, ...]]]:
        """Search for an album given album name and artist. Returns a list of (album_name, songs)"""
        for result in self._search(query_type="album", album=album, artist=artist):
            album_id: str = result['id']
            album_name: str = result['name']

            image_url: str = result.get('images', [{}])[0].get('url', None)
            image: Optional[Union[PNGSongImage, JPEGSongImage]] = self._fetch_image(image_url) \
                if image_url is not None else None

            songs_raw = self._all_items(self.api.album_tracks(album_id))
            songs = [self._parse_track(song_result).altered(album=album_name, cover_image=image)
                     for song_result in songs_raw]

            yield album_name, tuple(songs)

    def _get_playlist(self, playlist_id: str) -> Iterable[SongInformation]:
        for result in self._all_items(self.api.playlist_items(playlist_id, limit=100)):
            yield self._parse_track(result['track'])

    def search_song(self, song: str, album: str = None, artist: str = None) -> SongInformation:
        results = self._search_track(song, album, artist)
        if (song := next(results, None)) is None:
            raise ValueError("Couldn't find song on Spotify")
        return song

    def search_album(self, album: str, artist: str = None) -> Tuple[str, Tuple[SongInformation, ...]]:
        results = self._search_album_songs(album, artist)
        if (album := next(results, None)) is None:
            raise ValueError("Couldn't find album on Spotify")
        return album

    def get_playlist(self, playlist_id: str) -> Tuple[str, Tuple[SongInformation, ...]]:
        try:
            playlist_id = f"spotify:playlist:{playlist_id}"
            name = self.api.playlist(playlist_id)['name']
            return name, tuple(self._get_playlist(playlist_id))
        except:  # noqa
            raise ValueError("No such playlist")
